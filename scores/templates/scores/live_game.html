{% extends "scores/base.html" %}
{% load static %}

{% block content %}
<div class="container my-4">
  {# --- Page Heading --- #}
  <h1>Live Game: {{ game }} (Round {{ current_round }})</h1>

  {# --- Message Display Area (Info/Success/Error) --- #}
  <div id="message-display" class="alert {% if error %}alert-danger{% elif round_complete %}alert-success{% else %}alert-info{% endif %}" role="alert">
     {# --- Adjusted Message Text Logic --- #}
     <h4 id="message-text">
      {% if round_complete %}
        Round {{ current_round }} Complete!
      {% elif message %}
        {{ message }}
      {% else %}
        Enter score... {# Default message during play #}
      {% endif %}
     </h4>
     {# --- End Adjusted Message Text --- #}
    {% if error %}<p>Error: {{ error }}</p>{% endif %}
  </div>

  {# --- Form Validation Error Area (Populated by JS) --- #}
  <div id="form-errors" class="alert alert-danger" style="display: none;" role="alert"></div>

  {# --- Score Differential Display --- #}
  <div class="mb-3" id="plus-minus-container">
    {% if plus_minus is not None %}
      <p class="lead">Score Differential: <strong id="plus-minus-value">{% include "scores/partials/plus_minus_display.html" with plus_minus=plus_minus %}</strong></p>
    {% else %}
       <p class="lead" style="display: none;">Score Differential: <strong id="plus-minus-value"></strong></p>
    {% endif %}
  </div>

  {# --- Score Entry Form Wrapper --- #}
  <div id="score-form-wrapper" {% if round_complete or error %} style="display: none;" {% endif %}>
    <form method="post" id="score-form" action="{% url 'live_game' game.id %}" novalidate> {# Action remains 'live_game' for AJAX score submit #}
      {% csrf_token %}{{ score_form.as_p }}
      <button type="submit" name="enter_score" id="submit-score-btn" class="btn btn-success">Submit Score</button>
    </form>
  </div>

  {# --- Round Completion Display Wrapper --- #}
  {# This whole div is hidden/shown based on round_complete status #}
  <div id="round-complete-wrapper" {% if not round_complete %} style="display: none;" {% endif %}>
     <div class="alert alert-success">  {# This is the light green box #}
       <span id="round-complete-message" class="me-2">Round {{ current_round }} is complete.</span> {# Kept message, added margin #}

       {# --- UPDATED ACTION BUTTONS --- #}

       {# Button 1: Start Next Round - Action points to 'round_complete' URL #}
       <form method="post" action="{% url 'round_complete' game.id %}" style="display: inline-block;"> {# <<<< ACTION URL CHANGED #}
           {% csrf_token %}
           {# Hidden input removed - round_complete view uses session #}
           <button type="submit" name="next_round" class="btn btn-primary">Start Round {{ current_round|add:1 }}</button>
       </form>

       {# Button 2: End Game & View Stats - Action points to 'round_complete' URL #}
       <form method="post" action="{% url 'round_complete' game.id %}" style="display: inline-block;" class="ms-2"> {# <<<< ACTION URL CHANGED #}
           {% csrf_token %}
           <button type="submit" name="end_game" class="btn btn-warning">End Game & View Stats</button>
       </form>

       {# Button 3: Game Overview Link (Stays the same) #}
       <a href="{% url 'game_detail' game.id %}" class="btn btn-secondary ms-2">Game Overview</a>

       {# --- END OF UPDATED ACTION BUTTONS --- #}

     </div>
  </div>

  <hr>

  {# --- Scoreboard Section --- #}
  <h3>Scoreboard (Round {{ current_round }})</h3>
  <div id="scoreboard-container">
    {% if scores %}
      <table class="table table-striped" id="scores-table">
        <thead class="table-dark"><tr><th>Player</th><th>Cycle</th><th>Rolls</th><th>Total</th></tr></thead>
        <tbody id="scoreboard-body">
          {% for score in scores %}{% include "scores/partials/score_row.html" with score=score %}{% endfor %}
        </tbody>
      </table>
    {% else %}
      <p id="no-scores-message">No scores recorded yet for this round.</p>
    {% endif %}
  </div>
</div>

{# ========================== JavaScript (Unchanged from your last version) ========================== #}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- Get References (including error span) ---
    const scoreForm = document.getElementById('score-form');
    const messageTextEl = document.getElementById('message-text');
    const messageDisplayEl = document.getElementById('message-display');
    const formErrorsEl = document.getElementById('form-errors');
    const submitButton = document.getElementById('submit-score-btn');
    const plusMinusValueEl = document.getElementById('plus-minus-value');
    const plusMinusContainerEl = document.getElementById('plus-minus-container');
    const scoreboardBody = document.getElementById('scoreboard-body');
    const noScoresMsg = document.getElementById('no-scores-message');
    const scoreboardContainer = document.getElementById('scoreboard-container');
    const scoreFormWrapper = document.getElementById('score-form-wrapper');
    const roundCompleteWrapper = document.getElementById('round-complete-wrapper');
    const roundCompleteMessageEl = document.getElementById('round-complete-message');
    // NOTE: roundCompleteLink and roundCompleteError refs are kept below,
    // even though the elements are removed from HTML. The JS code has
    // checks (e.g., `if (roundCompleteLink && roundCompleteError ...)`),
    // so leaving the refs won't break it, but the conditions involving them
    // will now evaluate to false as the elements won't be found.
    const roundCompleteLink = document.getElementById('round-complete-link');
    const roundCompleteError = document.getElementById('round-complete-error');

    const initialPlusMinus = {{ plus_minus|default_if_none:"null" }};

    // Helper Functions (updatePlusMinusDisplay, renderScoreRow - unchanged)
    function updatePlusMinusDisplay(plusMinusValue) { if (!plusMinusValueEl || !plusMinusContainerEl) return; let displayText = ''; if (plusMinusValue > 0) displayText = `+${plusMinusValue} (Your Team Ahead)`; else if (plusMinusValue < 0) displayText = `${plusMinusValue} (Opponents Ahead)`; else displayText = `0 (Tied)`; plusMinusValueEl.innerHTML = displayText; const leadParagraph = plusMinusContainerEl.querySelector('.lead'); if (leadParagraph) leadParagraph.style.display = ''; }
    function renderScoreRow(score) { let targetTbody = document.getElementById('scoreboard-body'); if (noScoresMsg && noScoresMsg.style.display !== 'none') { let table = document.getElementById('scores-table'); if (!table && scoreboardContainer) { scoreboardContainer.innerHTML = `<table class="table table-striped" id="scores-table"><thead class="table-dark"><tr><th>Player</th><th>Cycle</th><th>Rolls</th><th>Total</th></tr></thead><tbody id="scoreboard-body"></tbody></table>`; targetTbody = document.getElementById('scoreboard-body'); } noScoresMsg.style.display = 'none'; } if (!targetTbody) { console.error("Scoreboard body not found!"); return; } let rollsText = ''; const rolls = [score.roll1, score.roll2, score.roll3]; const validRolls = rolls.filter(roll => roll !== null && roll !== undefined); rollsText = validRolls.join(', '); if (!rollsText) rollsText = '-'; const newRow = targetTbody.insertRow(); newRow.setAttribute('data-score-id', score.id); newRow.innerHTML = `<td>${score.player__name || 'N/A'}</td><td>${score.cycle_number || 'N/A'}</td><td>${rollsText}</td><td>${score.total !== null ? score.total : 'N/A'}</td>`; }

    // Initial Plus/Minus
    if (initialPlusMinus !== null) { updatePlusMinusDisplay(initialPlusMinus); }

    // AJAX Submit Handler
    if (scoreForm) {
      scoreForm.addEventListener('submit', function(event) {
        event.preventDefault();
        // UI Feedback Start
        if (submitButton) submitButton.disabled = true; if (messageTextEl && messageDisplayEl.classList.contains('alert-info')) messageTextEl.textContent = "Submitting score..."; /* Don't overwrite success/error messages */ if (messageDisplayEl && messageDisplayEl.classList.contains('alert-info')) messageDisplayEl.className = 'alert alert-info'; if (formErrorsEl) formErrorsEl.style.display = 'none';

        const formData = new FormData(scoreForm); const csrfToken = formData.get('csrfmiddlewaretoken');

        fetch(scoreForm.action, { method: 'POST', body: formData, headers: { 'X-CSRFToken': csrfToken, 'X-Requested-With': 'XMLHttpRequest', 'Accept': 'application/json' } })
        .then(response => { /* Error checking */ if (!response.ok) { return response.json().then(errData => { throw { status: response.status, data: errData }; }).catch(parseError => { throw { status: response.status, data: { error: `Server Error: ${response.statusText}` }}; }); } return response.json(); })
        .then(data => {
          // Handle success OR the specific "already complete" error case
          if (data.success || (data.success === false && data.round_complete === true && data.error === "Round already complete.")) {
            // Update message ONLY if it's not already a round complete message
            if (messageTextEl && data.message && !(data.round_complete && messageDisplayEl.classList.contains('alert-success'))) {
                messageTextEl.textContent = data.message;
            }
            if (data.plus_minus !== undefined) updatePlusMinusDisplay(data.plus_minus);
            if (data.success && data.new_score) { renderScoreRow(data.new_score); scoreForm.reset(); }

            // --- Check for Round Completion ---
            if (data.round_complete) {
                const finalMessage = `Round ${data.current_round || '{{ current_round }}'} Complete!`; // Construct final message
                if (messageTextEl) messageTextEl.textContent = finalMessage; // Update main message area
                if (messageDisplayEl) messageDisplayEl.className = 'alert alert-success'; // Ensure main area is success style
                if (scoreFormWrapper) scoreFormWrapper.style.display = 'none'; // Hide score form

                if (roundCompleteWrapper) {
                    // Update the specific message span inside the round complete wrapper if needed
                    if (roundCompleteMessageEl) roundCompleteMessageEl.textContent = `Round ${data.current_round || '{{ current_round }}'} is complete.`;

                    // --- JS related to the OLD link/error span will now safely do nothing ---
                    // The code below checks for `roundCompleteLink` and `roundCompleteError`.
                    // Since these elements no longer exist in the HTML, the `if` conditions
                    // will be false, and this block will have no effect.
                    if (roundCompleteLink && roundCompleteError && data.round_complete_url) {
                        // This code will not run as roundCompleteLink is null
                        // roundCompleteLink.href = data.round_complete_url;
                        // roundCompleteLink.style.display = '';
                        // roundCompleteError.style.display = 'none';
                        console.log("JS: (Old logic) Round complete, URL found:", data.round_complete_url);
                    } else if (roundCompleteLink && roundCompleteError) { // URL is null/missing
                        // This code will not run as roundCompleteLink is null
                        console.error("JS: (Old logic) Round complete, but URL missing/null:", data);
                        // roundCompleteLink.style.display = 'none';
                        // roundCompleteError.style.display = '';
                    }
                    // --- End of safely ignored old logic ---

                    roundCompleteWrapper.style.display = ''; // Show the wrapper containing the NEW buttons
                }
            } else if (data.success) { // Round NOT complete, score WAS successful
                 if (submitButton) submitButton.disabled = false;
                 const firstInput = scoreForm.querySelector('input[type="number"], input[type="text"]');
                 if(firstInput) { try { firstInput.focus(); } catch (e) { /* ignore */ } }
            } else { // !data.success and not round_complete (e.g. validation error from backend)
                 // We might receive validation errors even if success is false
                 if (submitButton) submitButton.disabled = false;
            }

          }
          // Handle validation errors specifically if not success and not round complete override
          if (!data.success && !(data.success === false && data.round_complete === true)) {
             if (data.errors && formErrorsEl) { /* Error display */ let errorHtml = '<strong>Errors:</strong><ul>'; for (const field in data.errors) { const fieldErrors = Array.isArray(data.errors[field]) ? data.errors[field] : [data.errors[field]]; fieldErrors.forEach(error => { errorHtml += `<li>${field === '__all__' ? '' : field + ': '}${error.message || error}</li>`; }); } errorHtml += '</ul>'; formErrorsEl.innerHTML = errorHtml; formErrorsEl.style.display = 'block'; if (messageTextEl) messageTextEl.textContent = "Submission failed."; if (messageDisplayEl) messageDisplayEl.className = 'alert alert-warning';
             } else if (data.error && formErrorsEl) { /* Generic error */ formErrorsEl.innerHTML = `<strong>Error:</strong> ${data.error}`; formErrorsEl.style.display = 'block'; if (messageTextEl) messageTextEl.textContent = "Submission failed."; if (messageDisplayEl) messageDisplayEl.className = 'alert alert-danger';
             } else if (!data.round_complete) { // Avoid throwing error if it was just a round_complete notification
                 console.warn("Submission failed with no specific errors provided:", data);
                 // Optionally show a generic message if needed, but avoid if formErrorsEl was populated
                 if (formErrorsEl.style.display === 'none') {
                    formErrorsEl.innerHTML = '<strong>Error:</strong> Submission failed for an unknown reason.';
                    formErrorsEl.style.display = 'block';
                    if (messageTextEl) messageTextEl.textContent = "Submission failed.";
                    if (messageDisplayEl) messageDisplayEl.className = 'alert alert-danger';
                 }
             }
             if (submitButton) submitButton.disabled = false;
          }

        })
        .catch(error => { /* Network/Fetch error handling */
          console.error('AJAX Error:', error); let errorMsg = 'Unexpected error.'; if (error && error.data && error.data.error) { errorMsg = `Error: ${error.data.error}`; } else if (error && error.status) { errorMsg = `Server error: ${error.status}.`; } else if (error instanceof Error && error.message) { errorMsg = error.message; } if (messageTextEl) messageTextEl.textContent = "Error."; if (messageDisplayEl) messageDisplayEl.className = 'alert alert-danger'; if (formErrorsEl) { formErrorsEl.innerHTML = `<strong>Error:</strong> ${errorMsg}`; formErrorsEl.style.display = 'block'; } if (submitButton) submitButton.disabled = false;
        });
      }); // End submit listener
    }

    // Initial focus
    if(scoreFormWrapper && scoreFormWrapper.style.display !== 'none') {
        const firstInputOnLoad = scoreForm.querySelector('input[type="number"], input[type="text"]');
        if(firstInputOnLoad) { try { firstInputOnLoad.focus(); } catch (e) { /* ignore */ } }
    }

}); // End DOMContentLoaded
</script>
{% endblock %}